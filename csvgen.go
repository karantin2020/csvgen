package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	. "github.com/dave/jennifer/jen"
	"github.com/karantin2020/cli"
	"github.com/karantin2020/csvgen/parser"
)

var (
	// Config vars
	pkg string
	subpkg string
	out string
	fname string
	// apn bool

	// Package vars
	pkgCnt string
	f *File
	p = parser.Parser{AllStructs: true}
)

func main() {
	flags := cli.New("This app generates csv Marshall and Unmarshal functions", "0.0.1")
	flags.StringVarP(&pkg, "pkg", "p", "", "output package")
	flags.StringVarP(&subpkg, "subpkg", "s", "", "output subpkg name")
	flags.StringVarP(&fname, "fname", "f", "", "input file")
	flags.StringVarP(&out, "out", "o", "", "output file")
	// flags.BoolVarP(&apn, "append", "a", false, "append result of template render to file or not")

	flags.Parse()

	pkgCnt = "main"
    if pkg != "" {
    	pkgCnt = pkg
    }
	if subpkg != "" {
		pkgCnt = subpkg
		pkg = ""
    }
    if out == "" {
		log.Fatal("didn't pass output file name")
		os.Exit(1)
	}
	if ok := strings.HasSuffix(out, ".go"); !ok {
		out = out + ".go"
	}
	if fname == "" {
		log.Fatal("didn't pass input file to parse")
		os.Exit(1)
	}

    // path := filepath.Join(subpkg, out + ".go")

// 	s := ""
// 	if !apn {
// 		s = `// This code is generated by 'csvgen'
// // DO NOT EDIT

// `
// 	}
// 	if !apn {
// 		s = s + pkgCnt
// 	}

	// ls := []Code{}
	// ls = append(ls, Qual("fmt", "Println").Call(Lit("Hello, world")))
	// f := Func().Id("main").Params().Block( ls... )
	

	// s = s + fmt.Sprintf("%#v", f)
	WriteString(/*subpkg, out, */pkgCnt/*, apn*/)
}

func WriteString(/*dir, name, */pkgCnt string/*, apn bool*/) {
	// var fileFlag int
	// if apn {
	// 	fileFlag = os.O_CREATE|os.O_WRONLY|os.O_APPEND
	// } else {
	// 	fileFlag = os.O_CREATE|os.O_TRUNC|os.O_WRONLY
	// }

	// if _, err := os.Stat(dir); os.IsNotExist(err) {
	// 	os.Mkdir(dir, os.ModePerm)
	// }

	// path := filepath.Join(dir, name + ".go")

	// if f,err := os.OpenFile(path, fileFlag, 0666); err != nil {
	// 	log.Fatal(err)
	// } else {
	// 	defer f.Close()
	// 	if _, err:= f.WriteString(s); err != nil {
	// 		log.Fatal(err)
	// 	}
	// }
	
	// fname := filepath.Join(dir, name + ".go")
	if _, err := os.Stat(subpkg); os.IsNotExist(err) {
		os.Mkdir(subpkg, os.ModePerm)
	}
	f = NewFile(pkgCnt)
	defer f.Save(filepath.Join(subpkg, out))

	f.Comment("This code is generated by 'csvgen'")
	f.Comment("Do not edit")
	f.Line()

	fInfo, err := os.Stat(fname)
	if err != nil {
		return
	}
	if err := p.Parse(fname, fInfo.IsDir()); err != nil {
		return
	}
	GenerateCode()
	fmt.Println(p.Error)
	fmt.Println(p.StructMap)
	fmt.Printf("%#v", f)
}

func GenerateCode() {

	for k, v := range p.StructMap {
		GenerateFuncs(k, v)
		f.Line()
	}

}

func GenerateFuncs(strName string, fields map[string]string) {

	// func (this *Type) UnmarshalCSV(in []string) error {
	// 	i := 0
	// 	if x, err := strconv.ParseBool(in[i]); err == nil {
	// 		this.b = x
	// 	} else {
	// 		return err
	// 	}
	// 	i++
	// 	if x, err := strconv.ParseInt(in[i], 10, 64); err == nil {
	// 		this.i = x
	// 	} else {
	// 		return err
	// 	}	
	// }
	// 
	// // func (this Type) MarshalCSV() (string, error) {
	// 		...marshal logic
	// }
	
	
	var unmarshallBody []Code
	var marshallBody []Code

	var initi = Id("i").Op(":=").Lit(0)
	unmarshallBody = append(unmarshallBody, initi)
	for fname, tname := range fields {
		switch tname {
		case "bool":
			g := If().List(Id("x"), Err()).Op(":=").Qual("strconv", "ParseBool").Call(Id("in").Lit("i")); err == nil {
				this.fname = x
			} else {
				return err
			}
		case "float32":
			fallthrough
		case "float64":
			if x, err := strconv.ParseFloat(in[i], 64); err == nil {
				this.fname = x
			} else {
				return err
			}
		case "int":
			fallthrough
		case "int32":
			fallthrough
		case "int64":
			if x, err := strconv.ParseInt(in[i], 10, 64); err == nil {
				this.fname = x
			} else {
				return err
			}
		case "string":
			this.fname = x
		case "uint":
			fallthrough
		case "uint32":
			fallthrough
		case "uint64":
			if x, err := strconv.ParseUint(in[i], 10, 64); err == nil {
				this.fname = x
			} else {
				return err
			}
		default:
			if err := json.Unmarshal(byt, &dat); err != nil {
		        return err
		    }
		// default:
		// 	log.Fatal("Type of struct field is not supported")
		}
	}

	f.Comment(strName + " Unmarshaller func")
	f.Func().Params(
		Id("this").Op("*").Id(strName),
	).Id("UnmarshalCSV").Params(
		Id("in").Index().String(),
	).Id("error").Block(
		unmarshallBody...,
	)

	f.Line()
	
	f.Comment(strName + " Marshaller func")
	f.Func().Params(
		Id("this").Id(strName),
	).Id("MarshalCSV").Params().
		Parens(Id("string").Op(",").Id("error")).Block(
		marshallBody...,
	)

}