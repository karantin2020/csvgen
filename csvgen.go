package main

import (
	"fmt"
	. "github.com/dave/jennifer/jen"
	"github.com/karantin2020/cli"
	"github.com/karantin2020/csvgen/parser"
	"os"
	"path/filepath"
	"strings"
)

var (
	// Config vars
	pkg    string
	subpkg string
	out    string
	fname  string
	fInfo  os.FileInfo

	// Package vars
	pkgCnt string
	f      *File
	p      = parser.Parser{AllStructs: true}
)

func main() {
	flags := cli.New("This app generates csv Marshall and Unmarshal functions", "0.0.1")
	flags.StringVarP(&pkg, "pkg", "p", "", "output package")
	flags.StringVarP(&subpkg, "subpkg", "s", "", "output subpkg name")
	flags.StringVarP(&fname, "fname", "f", "", "input file")
	flags.StringVarP(&out, "out", "o", "", "output file")

	flags.Parse()

	pkgCnt = "main"
	if pkg != "" {
		pkgCnt = pkg
	}
	if subpkg != "" {
		pkgCnt = subpkg
		pkg = ""
	}

	if fname == "" {
		fmt.Println("didn't pass source file to parse")
		os.Exit(1)
	}
	var err error
	if fInfo, err = os.Stat(fname); err != nil {
		fmt.Println("Couldn't find source file to parse.", err)
		os.Exit(1)
	}

	WriteString(pkgCnt)
}

func WriteString(pkgCnt string) {

	if err := p.Parse(fname, fInfo.IsDir()); err != nil {
		return
	}

	fmt.Println("fname is:", fname)
	if out == "" {
		subpkg = ""
		if fInfo.IsDir() {
			out = filepath.Join(fname, p.PkgName+"_csvgen.go")
		} else {
			if s := strings.TrimSuffix(fname, ".go"); s == fname {
				// return errors.New("Filename must end in '.go'")
				fmt.Println("Filename must end in '.go'")
				os.Exit(1)
			} else {
				out = s + "_csvgen.go"
			}
		}
		pkgCnt = p.PkgName
	} else {
		if s := strings.TrimSuffix(out, ".go"); s == out {
			out = out + ".go"
		}
	}
	fmt.Println("out is:", out)
	if subpkg != "" {
		if _, err := os.Stat(subpkg); os.IsNotExist(err) {
			fmt.Println(subpkg, "not exists. Trying to make directory")
			if err := os.Mkdir(subpkg, os.ModePerm); err != nil {
				fmt.Println("Couldn't make directory. Got an error:", err)
				os.Exit(1)
			}
		}
	}

	f = NewFile(pkgCnt)
	f.Comment("This code is generated by 'csvgen'")
	f.Comment("Do not edit")
	f.Line()

	GenerateCode()
	// fmt.Println(p.Error)
	// fmt.Println(p.StructMap)
	// fmt.Printf("%#v", f)
	if err := f.Save(filepath.Join(subpkg, out)); err != nil {
		fmt.Println("Couldn't save file. Got an error:", err)
		os.Exit(1)
	}
}

func GenerateCode() {

	for _, v := range p.Structs {
		GenerateFuncs(v)
		f.Line()
	}

}

// Generated functions MarshallCSV and UnmarshallCSV process builtin types,
// call MarshallCSV and UnmarshallCSV for custom types
// and process pointer types assuming that pointers were initiated (memory is
// allocated).
// So the best way is to verify data structures before marshalling
// and unmarshalling for null pointers to prevent SEGFAULT
func GenerateFuncs(vstr parser.StructInfo) {

	// func (this *Type) UnmarshalCSV(in []string) error {
	//  i := 0
	//  if x, err := strconv.ParseBool(in[i]); err == nil {
	//      this.b = x
	//  } else {
	//      return err
	//  }
	//  i++
	//  if x, err := strconv.ParseInt(in[i], 10, 64); err == nil {
	//      this.a = x
	//  } else {
	//      return err
	//  }
	// }
	//
	// // func (this Type) MarshalCSV() []string {
	//      out := []string{}
	//      out = append(out, strconv.FormatInt(int64(this.a), 10))
	//      out = append(out, strconv.FormatBool(this.b))
	//      ...marshal logic
	//      return out, nil
	// }

	var unmarshallBody []Code
	var marshallBody []Code

	unmarshallBody = append(unmarshallBody, Id("i").Op(":=").Lit(0))
	marshallBody = append(marshallBody, Id("out").Op(":=").Index().String().Values())

	for ik, istr := range vstr.Fields {
		var g, j *Statement
		star := ""
		ttype := istr.Type
		if istr.Type[0] == '*' {
			star = "*"
			ttype = istr.Type[1:]
		}

		unmarshallBody = append(unmarshallBody, nilCheck(star, istr.Name, istr.Type, false))
		marshallBody = append(marshallBody, nilCheck(star, istr.Name, istr.Type, true))
		switch ttype {
		case "bool":
			g = If(
				List(Id("x"), Err()).Op(":=").Qual("strconv", "ParseBool").Call(Id("in").Index(Id("i"))),
				Err().Op("!=").Nil(),
			).Add(genReturn(star, istr.Name, ttype))
			j = marshalBody(Qual("strconv", "FormatBool").Call(Op(star).Id("this").Op(".").Id(istr.Name)))
		case "float32":
			fallthrough
		case "float64":
			g = If(
				List(Id("x"), Err()).Op(":=").Qual("strconv", "ParseFloat").Call(List(Id("in").Index(Id("i")), Id(ttype[5:]))),
				Err().Op("!=").Nil(),
			).Add(genReturn(star, istr.Name, ttype))
			j = marshalBody(Qual("strconv", "FormatFloat").
				Call(Op("float64").Call(Op(star).Id("this").Op(".").Id(istr.Name)),
					LitRune('f'), Lit(-1), Id(ttype[5:])),
			)
		case "int":
			fallthrough
		case "int8":
			fallthrough
		case "int16":
			fallthrough
		case "int32":
			fallthrough
		case "int64":
			bn := ttype[3:]
			if bn == "" {
				bn = "0"
			}
			g = If(
				List(Id("x"), Err()).Op(":=").Qual("strconv", "ParseInt").Call(List(Id("in").Index(Id("i")), Lit(10), Id(bn))),
				Err().Op("!=").Nil(),
			).Add(genReturn(star, istr.Name, ttype))
			j = marshalBody(Qual("strconv", "FormatInt").
				Call(Op("int64").Call(Op(star).Id("this").Op(".").Id(istr.Name)), Lit(10)),
			)
		case "uint":
			fallthrough
		case "uint8":
			fallthrough
		case "uint16":
			fallthrough
		case "uint32":
			fallthrough
		case "uint64":
			bn := ttype[4:]
			if bn == "" {
				bn = "0"
			}
			g = If(
				List(Id("x"), Err()).Op(":=").Qual("strconv", "ParseUint").
					Call(List(Id("in").Index(Id("i")), Lit(10), Id(bn))),
				Err().Op("!=").Nil(),
			).Add(genReturn(star, istr.Name, ttype))
			j = marshalBody(Qual("strconv", "FormatUint").
				Call(Op("uint64").Call(Op(star).Id("this").Op(".").Id(istr.Name)), Lit(10)),
			)
		case "string":
			g = Op(star).Id("this").Op(".").Id(istr.Name).Op("=").Id("in").Index(Id("i"))
			j = marshalBody(Op(star).Id("this").Op(".").Id(istr.Name))
		default:
			// By default generated code calls 'func (this *Type) UnmarshallCSV(s string) error'
			g = If(
				Err().Op(":=").Id("this").Op(".").Id(istr.Name).Op(".").Id("UnmarshallCSV").
					Call(Id("in").Index(Id("i"))),
				Err().Op("!=").Nil(),
			).Block(
				Return().Err(),
			)
			// By default generated code calls 'func (this Type) MarshallCSV() (string, error)'
			j = If(
				List(Id("mt"), Err()).Op(":=").Id("this").Op(".").Id(istr.Name).Op(".").Id("MarshallCSV").
					Call(),
				Err().Op("!=").Nil(),
			).Block(
				Return(Id("out"), Err()),
			).Else().Block(
				marshalBody(Id("mt")),
			)
		}
		unmarshallBody = append(unmarshallBody, g)
		marshallBody = append(marshallBody, j)
		if ik != (len(vstr.Fields) - 1) {
			unmarshallBody = append(unmarshallBody, Id("i").Op("+=").Lit(1))
		} else {
			unmarshallBody = append(unmarshallBody, Return().Id("nil"))
			marshallBody = append(marshallBody, Return().List(Id("out"), Id("nil")))
		}
	}

	f.Comment(vstr.Name + " Unmarshaller func")
	f.Func().Params(
		Id("this").Op("*").Id(vstr.Name),
	).Id("UnmarshalCSV").Params(
		Id("in").Index().String(),
	).Id("error").Block(
		unmarshallBody...,
	)

	f.Line()

	f.Comment(vstr.Name + " Marshaller func")
	f.Func().Params(
		Id("this").Id(vstr.Name),
	).Id("MarshalCSV").Params().
		Parens(Index().String().Op(",").Id("error")).Block(
		marshallBody...,
	)
}

func genReturn(star string, fieldName string, fieldType string) *Statement {
	var conv *Statement

	//  Check for float and int
	if fieldType[len(fieldType)-2:] != "64" {
		conv = Id(fieldType).Call(Id("x"))
	} else {
		conv = Id("x")
	}
	return Block(
		Op(star).Id("this").Op(".").Id(fieldName).Op("=").Add(conv),
	).Else().Block(
		Return().Err(),
	)
}

func marshalBody(typeRes *Statement) *Statement {
	return Id("out").Op("=").Id("append").Call(Id("out"), Add(typeRes))
}

func nilCheck(star string, iname, itype string, marshall bool) *Statement {
	var s, t *Statement
	if marshall {
		t = List(Id("out"), Qual("errors", "New").Call(Lit("nil pointer found at "+iname+" "+itype)))
	} else {
		t = Qual("errors", "New").Call(Lit("nil pointer found at " + iname + " " + itype))
	}
	if star == "*" {
		s = If(
			Id("this").Op(".").Id(iname).Op("==").Id("nil"),
		).Block(
			Return().Add(t),
		)
	} else {
		s = Null()
	}
	return s
}
