package main

import (
	"fmt"
	. "github.com/dave/jennifer/jen"
	"github.com/karantin2020/cli"
	"github.com/karantin2020/csvgen/parser"
	"log"
	"os"
	"path/filepath"
	"strings"
)

var (
	// Config vars
	pkg    string
	subpkg string
	out    string
	fname  string
	// apn bool

	// Package vars
	pkgCnt string
	f      *File
	p      = parser.Parser{AllStructs: true}
)

func main() {
	flags := cli.New("This app generates csv Marshall and Unmarshal functions", "0.0.1")
	flags.StringVarP(&pkg, "pkg", "p", "", "output package")
	flags.StringVarP(&subpkg, "subpkg", "s", "", "output subpkg name")
	flags.StringVarP(&fname, "fname", "f", "", "input file")
	flags.StringVarP(&out, "out", "o", "", "output file")
	// flags.BoolVarP(&apn, "append", "a", false, "append result of template render to file or not")

	flags.Parse()

	pkgCnt = "main"
	if pkg != "" {
		pkgCnt = pkg
	}
	if subpkg != "" {
		pkgCnt = subpkg
		pkg = ""
	}
	if out == "" {
		log.Fatal("didn't pass output file name")
		os.Exit(1)
	}
	if ok := strings.HasSuffix(out, ".go"); !ok {
		out = out + ".go"
	}
	if fname == "" {
		log.Fatal("didn't pass input file to parse")
		os.Exit(1)
	}

	// path := filepath.Join(subpkg, out + ".go")

	//  s := ""
	//  if !apn {
	//      s = `// This code is generated by 'csvgen'
	// // DO NOT EDIT

	// `
	//  }
	//  if !apn {
	//      s = s + pkgCnt
	//  }

	// ls := []Code{}
	// ls = append(ls, Qual("fmt", "Println").Call(Lit("Hello, world")))
	// f := Func().Id("main").Params().Block( ls... )

	// s = s + fmt.Sprintf("%#v", f)
	WriteString( /*subpkg, out, */ pkgCnt /*, apn*/)
}

func WriteString( /*dir, name, */ pkgCnt string /*, apn bool*/) {
	// var fileFlag int
	// if apn {
	//  fileFlag = os.O_CREATE|os.O_WRONLY|os.O_APPEND
	// } else {
	//  fileFlag = os.O_CREATE|os.O_TRUNC|os.O_WRONLY
	// }

	// if _, err := os.Stat(dir); os.IsNotExist(err) {
	//  os.Mkdir(dir, os.ModePerm)
	// }

	// path := filepath.Join(dir, name + ".go")

	// if f,err := os.OpenFile(path, fileFlag, 0666); err != nil {
	//  log.Fatal(err)
	// } else {
	//  defer f.Close()
	//  if _, err:= f.WriteString(s); err != nil {
	//      log.Fatal(err)
	//  }
	// }

	if _, err := os.Stat(subpkg); os.IsNotExist(err) {
		fmt.Println(subpkg, "not exists. Trying to make directory")
		if err := os.Mkdir(subpkg, os.ModePerm); err != nil {
			fmt.Println("Couldn't make directory. Got an error:", err)
			os.Exit(1)
		}
	}
	f = NewFile(pkgCnt)
	defer func() {
		if err := f.Save(filepath.Join(subpkg, out)); err != nil {
			fmt.Println("Couldn't save file. Got an error:", err)
			os.Exit(1)
		}
	}()

	f.Comment("This code is generated by 'csvgen'")
	f.Comment("Do not edit")
	f.Line()

	fInfo, err := os.Stat(fname)
	if err != nil {
		fmt.Println("Couldn't find source file to parse")
		os.Exit(1)
	}
	if err := p.Parse(fname, fInfo.IsDir()); err != nil {
		return
	}
	GenerateCode()
	fmt.Println(p.Error)
	fmt.Println(p.StructMap)
	fmt.Printf("%#v", f)
}

func GenerateCode() {

	for _, v := range p.Structs {
		GenerateFuncs(v)
		f.Line()
	}

}

func GenerateFuncs(vstr parser.StructInfo /*, fields map[string]string*/) {

	// func (this *Type) UnmarshalCSV(in []string) error {
	//  i := 0
	//  if x, err := strconv.ParseBool(in[i]); err == nil {
	//      this.b = x
	//  } else {
	//      return err
	//  }
	//  i++
	//  if x, err := strconv.ParseInt(in[i], 10, 64); err == nil {
	//      this.i = x
	//  } else {
	//      return err
	//  }
	// }
	//
	// // func (this Type) MarshalCSV() (string, error) {
	//      ...marshal logic
	// }

	var unmarshallBody []Code
	var marshallBody []Code

	unmarshallBody = append(unmarshallBody, Id("i").Op(":=").Lit(0))

	for ik, istr := range vstr.Fields {
		var g, j, s *Statement
		star := ""
		ttype := istr.Type
		if istr.Type[0] == '*' {
			star = "*"
			ttype = istr.Type[1:]
		}
		if star == "*" {
			s = If(
				Id("this").Op(".").Id(istr.Name).Op("==").Id("nil"),
			).Block(
				Return().Qual("errors", "New").Call(Lit("nil pointer found at " + istr.Name + " " + istr.Type)),
			)
		} else {
			s = Null()
		}
		j = Block(
			s,
			Op(star).Id("this").Op(".").Id(istr.Name).Op("=").Id("x"),
			Return().Nil(),
		).Else().Block(
			Return().Err(),
		)
		switch ttype {
		case "bool":
			g = If(
				List(Id("x"), Err()).Op(":=").Qual("strconv", "ParseBool").Call(Id("in").Index(Id("i"))),
				Err().Op("!=").Nil(),
			).Add(j)
		case "float32":
			fallthrough
		case "float64":
			g = If(
				List(Id("x"), Err()).Op(":=").Qual("strconv", "ParseFloat").Call(List(Id("in").Index(Id("i")), Id(istr.Type[5:]))),
				Err().Op("!=").Nil(),
			).Add(j)
		case "int":
			// By default int is always equal to int64
			fallthrough
		case "int32":
			fallthrough
		case "int64":
			bn := 64
			if len(istr.Type) > 3 && istr.Type[4] == '2' {
				bn = 32
			}
			g = If(
				List(Id("x"), Err()).Op(":=").Qual("strconv", "ParseInt").Call(List(Id("in").Index(Id("i")), Lit(bn))),
				Err().Op("!=").Nil(),
			).Add(j)
		case "uint":
			// By default uint is always equal to uint64
			fallthrough
		case "uint32":
			fallthrough
		case "uint64":
			bn := 64
			if len(istr.Type) > 4 && istr.Type[5] == '2' {
				bn = 32
			}
			g = If(
				List(Id("x"), Err()).Op(":=").Qual("strconv", "ParseUint").
					Call(List(Id("in").Index(Id("i")), Lit(10), Lit(bn))),
				Err().Op("!=").Nil(),
			).Add(j)
		case "string":
			unmarshallBody = append(unmarshallBody, s)
			g = Op(star).Id("this").Op(".").Id(istr.Name).Op("=").Id("in").Index(Id("i"))
		default:
			op := "&"
			if star == "*" {
				op = ""
			}
			g = If(
				Err().Op(":=").Qual("encoding/json", "Unmarshal").
					Call(List(Index().Byte().Parens(Id("in").Index(Id("i"))), Op(op).Id("this").Op(".").Id(istr.Name))),
				Err().Op("!=").Nil(),
			).Block(
				Return().Err(),
			)
		}
		unmarshallBody = append(unmarshallBody, g)
		if ik != (len(vstr.Fields) - 1) {
			unmarshallBody = append(unmarshallBody, Id("i").Op("+=").Lit(1))
		}
	}

	f.Comment(vstr.Name + " Unmarshaller func")
	f.Func().Params(
		Id("this").Op("*").Id(vstr.Name),
	).Id("UnmarshalCSV").Params(
		Id("in").Index().String(),
	).Id("error").Block(
		unmarshallBody...,
	)

	f.Line()

	f.Comment(vstr.Name + " Marshaller func")
	f.Func().Params(
		Id("this").Id(vstr.Name),
	).Id("MarshalCSV").Params().
		Parens(Id("string").Op(",").Id("error")).Block(
		marshallBody...,
	)
}
